## 1. 경쟁 상태와 동시성 제어

### 1.1 경쟁 상태(Race Condition)

- 경쟁 상태는 두 개 이상의 프로세스(또는 스레드)가 동일한 자원에 동시에 접근하여 읽기-수정-쓰기 작업을 수행할 때, 실행 순서나 타이밍에 따라 최종 결과가 개발자의 의도와 다르게 나오는 현상을 말합니다.
- 경쟁 상태가 발생하면 데이터 무결성이 깨지거나 비즈니스 로직에 치명적인 오류(예: 잘못된 재고 수량, 중복 쿠폰 발급)가 발생할 수 있습니다.

### 1.2 동시성 제어 목표

동시성 제어는 여러 프로세스나 스레드가 **공유 자원에 동시에 접근**하거나 **병렬 작업**을 수행할 때, **데이터 무결성과 일관성을 보장하기 위해 실행 순서와 접근을 조정하는 메커니즘**입니다.  이를 통해 경쟁 상태를 방지하고 시스템이 안정적으로 동작할 수 있도록 보장합니다.

- 동시성 제어의 핵심 목표
    - **데이터 일관성 보장:** 동시 작업 중에도 공유 자원의 상태를 정확히 유지하여 잘못된 결과가 발생하지 않도록 합니다.
    - **비즈니스 로직 보호:** 작업이 의도된 실행 순서대로 처리되도록 보장하여, 중요한 비즈니스 규칙을 위반하지 않도록 합니다.
    - **경쟁 상태 방지:** 여러 작업이 동시에 실행되더라도, 각 작업이 독립적으로 처리될 수 있도록 조정하여 데이터 충돌 및 손상 문제를 방지합니다.
    - **성능과 안정성 간 균형 유지**: 동시성 제어는 데이터를 안전하게 다루는 동시에, 시스템 성능 저하를 최소화하여 빠른 응답 시간과 높은 처리량을 유지할 수 있도록 설계되어야 합니다.

---

## 2. 동시성 문제 해결 방법

동시성 문제를 해결하려면 **데이터 무결성**을 보장하면서도 **성능과 확장성**을 유지해야 합니다. 하지만 현실적으로 모든 상황에서 완벽한 방법은 없으며 상황에 따른 트레이드오프를 고려해 해결책을 모색해야 합니다.

**2.1 트랜잭션 격리 수준(Transaction Isolation Level)**

- 데이터베이스가 제공하는 기본적인 동시성 제어 메커니즘으로, 격리 수준을 통해 트랜잭션간 읽기/쓰기 충돌을 DB 내부에서 제어합니다. 
- 격리 수준이 높을 수록 데이터 정합성이 잘 보장되지만 성능이 저하될 수 있습니다. 
- 읽기 관련 문제(Dirty Read, Non-Repeatable Read, Phantom Read)를 방지하는데 초점이 맞춰져 있고, 쓰기-쓰기 충돌은 별도의 락이나 논리적 동시성 제어 메커니즘이 필요합니다.

**2.2 DB 락 (Lock)**

- **비관적 락(Pessimistic Lock)**

충돌이 많이 발생할 것이라는 방어적인 접근 전략으로, 데이터를 읽기 전에 락을 걸어 다른 트랜잭션의 접근을 사전에 차단합니다. 
데이터 무결성은 최상으로 유지할 수 있지만 락 점유 시간이 길어지면 교착 상태(데드락)가 발생할 수 있고, 대규모 시스템에서는 병목 현상의 주범입니다.

- **낙관적 락(Optimistic Lock)**

충돌이 발생하지 않을 것이라는 신뢰를 기반으로 하는 접근 전략으로, 충돌을 사전에 막지 않고 발생시 대응합니다. 물리적 락을 걸지 않아 성능이 우수하고 업데이트 시 버전을 비교하는 방식으로 구현이 간단합니다. 하지만 충돌이 자주 일어난다면 재시도가 반복되어 오히려 비효율적입니다.

**2.3 분산 락(Distributed Lock)**

분산 락은 여러 서버가 자원을 동시에 관리해야 하는 대규모 환경에서 효과적입니다.  Redis 와 같은 도구를 활용해 구현합니다. 락 만료 시간(Time-to-Live)을 설정해 교착상태를 방지할 수 있고 높은 처리량을 지원합니다. 하지만 별도의 인프라를 운영하므로 복잡도가 증가할 수 있고 락 만료 시간, 재시도 간격등 설계가 까다롭습니다.

**2.4 메시지 큐(Message Queue)**

작업이나 이벤트를 순차적으로 큐에 저장하고, 이를 하나씩 처리함으로써 충돌이나 경쟁 조건을 방지하는 방식입니다.  RabbitMQ, Kafka, AWS SQS와 같은 도구가 주로 사용됩니다. 비동기 처리와 트래픽 분산에 강점이 있지만, 큐 내 대기 시간이 발생할 수 있어 실시간 응답이 중요한 서비스에는 적합하지 않을 수 있습니다.

---

## 3. e-commerce 시나리오별 문제 상황과 해결 방법

### (1) 상품 재고 관리

### 1) 문제 상황

- 인기 있는 상품이 한정된 재고로 판매될 때, 여러 사용자가 동시에 구매 요청을 보내면 경쟁 상태가 발생합니다. 재고 조회와 업데이트 사이의 시간 차이로 인해 동일한 재고가 여러 번 판매될 수 있습니다. 이는 재고가 음수로 떨어지거나 초과 주문이 발생하는 문제로 이어질 수 있습니다.

### 2) 해결 방안

1. **낙관적 락(Optimistic Lock)**
    - 적합한 시나리오 : 재고 갱신 충돌이 빈번하지 않은 경우
    - 재고 관리에서는 충돌 발생 시 재시도 로직이 복잡해질 수 있지만, 대규모 트래픽 환경에서 성능을 유지할 수 있는 장접이 큽니다.
2. **비관적 락(Pessimistic Lock)**
    - 적합한 시나리오 : 재고 소진이 빠르게 발생하고, 높은 정합성이 요구되는 경우
    - 재고의 정확성이 최우선일 때 효과적이나, 트래픽이 급증할 경우 성능 저하와 교착 상태의 위험이 큽니다.
3. **분산 락(Distributed Lock)**
    - 적합한 시나리오 :  분산 환경에서 재고가 실시간으로 처리되어야 하는 경우
    - 추가적인 인프라가 필요하고 세부 구현이 복잡할 수 있지만 실시간 재고 상태를 유지할 수 있고 TTL 설정을 통해 락이 해제되지 않는 문제를 방지할 수 있습니다.
4. 메세지 큐(Message Queue)
    - 적합한 시나리오 : 대규모 트래픽 발생시 재고 변경 작업을 비동기적으로 처리하는 경우
    - **추가적인 인프라가 필요하고 큐 관리 및 메시지 처리 실패시 재시도 전략 등 복잡도가 높지만주문 요청을 비동기적으로 관리**하여 서버 부하를 감소시켜 대량의 주문 요청을 효과적으로 분산처리 할 수 있습니다.

### 4) 현재 구현

- **비관적 락**을 사용

### 5) 이유

- 재고 데이터의 정합성을 우선적으로 고려했고, 특히 재고 소진이 빠르게 발생하는 상황에서 확실한 데이터 일관성을 유지할 필요가 있습니다. 충돌 가능성을 원천 차단하여 재고 초과 문제를 방지하려는 의도였습니다.

### 6) 개선 방안

- 분산 락 적용 검토
    - 인기 상품 재고 관리와 같은 고 트래픽 상황에서 Redis 기반 분산 락을 도입하면, 비관적 락의 동시성 제한 문제를 완화하면서도 높은 처리량을 유지할 수 있습니다.
    - 락 갱신과 타임아웃 설정을 통해 교착 상태를 방지해야 합니다.

---

### (2) 선착순 쿠폰 발급

### 1) 문제 상황

- 발급 수량이 한정된 선착순 쿠폰 이벤트를 진행할 때 동시에 수천에서 수만 건 이상의 발급 요청이 들어올 경우, 쿠폰이 초과 발급될 수 있습니다. 또한 쿠폰 발급 수량을 관리하는 DB에 트래픽이 집중되면 병목 현상이 발생할 수 있습니다.

### 2 ) 해결 방안

1. 낙관적 락
    - 적합한 **시나리오:** 쿠폰 발급 수량이 많거나 충돌 가능성이 상대적으로 낮고, 발급 실패 시 빠르게 재시도할 수 있는 경우.
    - 한정된 수량의 쿠폰을 발급할 때는 충돌이 빈번하게 발생할 가능성이 높아, 낙관적 락의 효율성이 떨어질 수 있습니다.
2. 비관적 락
    - 적합한 **시나리오:** 쿠폰 발급 수량이 매우 한정적이고, 발급 정확성이 최우선일 때.
    - 초과 발급을 원천 차단하며 데이터 정합성을 보장하지만 트래픽이 급증할 경우 성능 저하와 교착 상태의 위험이 존재합니다.
3. **분산 락**
    - 적합한 시나리오 : 대규모 분산 시스템에서 동시 발급 요청을 안전하게 처리해야 하는 경우
    - Redis 는 메모리 기반으로 빠른 응답성을 제공하므로, 대량의 요청을 효율적으로 처리할 수 있습니다. Redis 장애 시 쿠폰 발급 시스템 전체가 영향을 받을 수 있습니다.
4. 메세지 큐
    - 적합한 시나리오 : 발급 요청을 순차적으로 처리하며 초과 발급을 방지해야 하는 경우
    - 초과 발급을 완벽히 방지하고 병목 현상을 완화하지만 실시간 발급 응답 속도가 느려질 수 있습니다.

### 4) 현재 구현

- 비관적 락
- **분산 락(Redis)**

### 5) 이유
- 충돌이 많을 것을 고려해 비관적 락으로 구현했다가 분산 락 개념을 학습 후 레디스를 적용해봤습니다.
- 선착순 이벤트는 트래픽이 급증하며 높은 동시성이 요구됩니다. Redis 분산 락은 초과 발급 방지와 동시에 높은 성능을 제공하며, 트래픽 폭증에도 안정적인 처리가 가능합니다.

---

### (3) 포인트 잔액 관리

### 1) 문제 상황

- 동일 사용자가 여러 기기로 동시에 로그인하여 포인트를 충전하거나 사용 요청을 할 경우, 실제 잔액과 DB상 잔액이 불일치 할 수 있습니다.

### 2) 해결 방안

1. **낙관적 락(Optimistic Lock)**
    - 적용 시나리오 : 사용자별 포인트 갱신 빈도가 낮고, 충돌 가능성이 상대적으로 낮은 경우
    - 대부분의 사용자는 동시에 다수의 포인트 거래를 시도하지 않으므로 낙관적 락을 통해 높은 동시성을 유지하면서도 데이터 정합성을 보장할 수 있습니다. 다만 일부 고빈도 사용자에 대한 충돌 처리 로직을 고려해야합니다.
2. **비관적 락(Pessimistic Lock)**
    - 적용 시나리오 : 포인트 잔액 변동이 빈번하고, 높은 정합성이 요구되는 경우
    - 포인트는 금전적 가치가 있으므로 정확한 관리가 필수적입니다. 하지만 동시에 트랜잭션이 많아지면 성능 저하와 교착 상태의 위험이 커집니다.

### 4) 현재 구현

- **낙관적 락**

### 5) 이유

- 대부분의 사용자들은 동시에 여러 기기에서 포인트를 갱신하지 않으며, 포인트 갱신 요청이 상대적으로 낮은 빈도로 발생합니다. 따라서 낙관적 락을 사용하면 불필요한 락 경합을 피하면서도 데이터 정합성을 유지할 수 있습니다. 