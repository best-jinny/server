# 1. 캐시는 무엇일까?

캐시는 데이터를 임시로 저장하여 더 빠르게 접근할 수 있도록 돕는 작은 저장소다.

예를 들어 우리집 냉장고가 캐시라고 생각해보자.

배고플 때마다 마트(DB)까지 가지 않고 미리 사다 놓은 쌀이랑 김, 두부를 바로 꺼내먹는다.

이처럼 **자주 먹는 음식(자주 조회하는 데이터)** 이 냉장고(캐시)에 있다면, 빠르게 사용할 수 있다. 이를 **`캐시 히트(Cache Hit)`** 라고 한다.

그런데 오늘은 상추가 먹고 싶은데 냉장고에 없다. 원하는 데이터가 캐시에 존재하지 않는 상황을 **`캐시 미스(Cache Miss)`** 라고 한다.

캐시에 없으면 마트(DB)까지 가서 사와야 한다. 캐시 미스가 계속 발생하면 비효율적이고 캐시가 의미가 없을 것이다.

그래서 **캐시 전략**을 사용해 어떤 데이터를 냉장고에 보관할지 정하는 게 중요하다.

---

# 2. 캐시 전략 4가지 키워드

우리가 냉장고를 효율적으로 운영하려면, 어떤 음식을 미리 저장할지 정하는 전략이 필요하다.

캐시에서도 마찬가지로, 데이터를 언제 캐시에 저장하고 언제 갱신할지 결정하는 전략이 있다.

**나 (애플리케이션) - 냉장고 (캐시) - 마트 (DB)**

## (1) Cache-Aside : 내가 직접 관리하는 냉장고

- **“음식이 없으면 직접 마트에서 사와서 냉장고에 넣는다.”**
- 냉장고는 그냥 저장소 역할이고, 냉장고 시스템이 자동으로 채워주지 않음.
- 가장 기본적인 전략이며, 데이터 변경 시 캐시 갱신이 필요하다.
- **이커머스 서비스에서는 상품 조회, 인기 상품 등에 사용할 수 있다.**

## (2) Read-Through : 자동 주문 냉장고

- **“냉장고에 음식이 없으면, 냉장고가 알아서 마트에 주문해 채운다.”**
- 즉, 모든 읽기 요청이 먼저 캐시로 가고, 캐시 미스 시 자동으로 DB에서 데이터를 로드하여 저장.
- 애플리케이션 코드가 단순해지지만 **DB 데이터가 직접 수정될 경우 캐시 불일치 발생 가능성**이 있다.

## (3) Write-Through

- **“냉장고에 넣으면 마트에도 자동 반영”**
- 캐시와 DB 데이터 불일치 문제가 적지만 **속도가 느릴 수 있다**.

## (4) Write-Behind

- **“일단 냉장고에 넣어두고, 나중에 마트에 반영”**
- 데이터를 캐시에 먼저 기록하고, 일정 시간이 지나거나 특정 조건이 충족될 때 DB에 반영한다.
- **쓰기 성능이 향상되지만**, 캐시에 저장된 데이터가 DB에 반영되기 전에 장애가 발생하면 **데이터 유실 가능성이 있다**.
- **조회수, 좋아요 등에 사용**.

---

# 3. 인기 상품 조회 API의 캐시 적용 전략

현재 **인기 상품 조회 API** 는 요청이 올 때마다 복잡한 집계 쿼리를 실행하여 DB에 부하를 준다.

`orderLine` 테이블은 트랜잭션 데이터가 쌓이는 테이블이므로 시간이 지날수록 데이터가 많아지면서 **쿼리 실행 시간이 점점 길어질 것이다**.

반복되는 `SUM`, `GROUP BY`, `ORDER BY`, `LIMIT` 연산은 **성능에 큰 영향을 미칠 수 있으며 DB에 과부하를 초래**할 수 있다.

그리고 **인기 상품 데이터는 순간적으로 크게 변하지 않는데**, 요청마다 계속 DB를 조회하는 것은 **비효율적**이다.

게다가 **인기 상품 조회는 트래픽이 많을 가능성이 크다**. 데이터를 주기적으로 캐시에 저장하고 **재사용하는 전략**이 필요하다!

스프링에서는 `@Cacheable` 어노테이션으로 **Cache-Aside 방식의 캐시**를 적용할 수 있다.

캐시는 일정 시간 동안 유지되다가 만료되어야 한다. (**TTL: Time-to-Live**)

그러나 **TTL이 만료되었을 때 갑자기 다수의 요청이 DB로 몰리는 `캐시 스탬피드(Cache Stampede)` 현상이 발생할 수 있다**. 이를 방지하기 위해서는 다음과 같은 전략을 적용할 수 있다.

## 캐시 스탬피드(Cache Stampede) 방지 전략

1. **TTL 랜덤화**
   - 각 캐시의 TTL에 작은 랜덤값을 추가하여 **만료 시점을 분산**시킨다.
   - 예를 들어 기본 TTL이 1시간이라면, **55~65분 사이의 랜덤한 값을 적용**.

2. **캐시 워밍(Cache Warming)**
   - 서비스 시작 시점이나 **캐시 만료 전에 미리 데이터를 캐시에 적재**한다.
   - 구현 방법:
      - **애플리케이션 구동 시 `@PostConstruct`로 초기 데이터 적재**
      - **`@Scheduled`을 사용해 주기적으로 캐시 갱신**
      - **피크 타임을 피해 갱신하도록 스케줄링**

아직 구현하지는 못했지만 위의 전략을 사용해서 적용해 볼 예정이다.
